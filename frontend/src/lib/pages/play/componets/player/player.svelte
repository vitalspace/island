<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.0 .\boat.glb -T --draco /draco/
-->

<script lang="ts">
  import type { RigidBody as RapierRigidBody } from "@dimforge/rapier3d-compat";
  import { T, useTask, useThrelte } from "@threlte/core";
  import { useGltf, useDraco, Outlines, HTML } from "@threlte/extras";
  import { AutoColliders, RigidBody } from "@threlte/rapier";
  import { Group, Mesh, PerspectiveCamera, Vector3 } from "three";
  import { PointerDrag } from "../../controls/pointerDrag";
  import { PointerLock } from "../../controls/pointerLock";
  import { ThirdPersonControls } from "../../controls/thirdPersonControls";
  import Bullet from "./Bullet.svelte";

  let {
    player,
    socket,
    fallback = () => {},
    error = () => {},
    children = () => {},
    ref = $bindable(),
    ...props
  } = $props();

  const gltf = useGltf("/boat-transformed.glb", { dracoLoader: useDraco() });
  const { camera } = useThrelte();

  let mainGroupRef: Group | undefined = $state<Group>();
  let objectRef: Group | undefined = $state<Group>();
  let rigidBody: RapierRigidBody | undefined = $state<RapierRigidBody>();
  let canonRef: Mesh | undefined = $state(); // Añadir tipo explícito
  let cameraRef: PerspectiveCamera | undefined = $state<PerspectiveCamera>();
  let controls: ThirdPersonControls | undefined;
  let position: [number, number, number] = $state<[number, number, number]>([
    player.position.x,
    player.position.y,
    player.position.z,
  ]);

  $effect(() => {
    if (objectRef && cameraRef) {
      const isTouchDevice = "ontouchstart" in window;
      const canvas = document.querySelector("canvas");

      // @ts-ignore
      controls = new ThirdPersonControls($camera, mainGroupRef, {
        offset: new Vector3(0, 3, 0),
        targetRadius: 15,
        interpolationFactor: 0.05,
      });
      controls.theta = 90;

      if (!isTouchDevice && canvas) {
        let pl = new PointerLock(canvas);
        let pd = new PointerDrag(canvas);
        pd.onMove((delta) => {
          if (pl.isLocked()) {
            controls?.update(delta.x * 2, delta.y * 2);
          }
        });
      }
    }
  });

  let speed = 6;
  const keys = { w: { pressed: false }, shift: { pressed: false } };

  const press = (e: KeyboardEvent, isPressed: boolean) => {
    e.preventDefault();
    if (e.key === "w" || e.key === "W") keys.w.pressed = isPressed;
    if (e.key === "Shift") keys.shift.pressed = isPressed;
  };

  window.addEventListener("keydown", (e) => press(e, true));
  window.addEventListener("keyup", (e) => press(e, false));

  const v3 = new Vector3();

  useTask(() => {
    if (!rigidBody || !objectRef || !cameraRef || !controls) return;

    const rotation = cameraRef.getWorldDirection(v3);
    const theta = Math.atan2(rotation.x, rotation.z);
    const rotationObj = objectRef.getWorldDirection(v3);
    const thetaObject = Math.atan2(rotationObj.x, rotationObj.z);

    rigidBody.setAngvel({ x: 0, y: 0, z: 0 }, true);

    const angleDiff = Math.abs(theta - thetaObject);
    const threshold = Math.PI / 24;

    if (angleDiff > threshold) {
      let rotationSpeed = 5;
      if (angleDiff > Math.PI - threshold) rotationSpeed *= -1;
      if (theta < thetaObject) rotationSpeed *= -1;
      rigidBody.setAngvel({ x: 0, y: rotationSpeed, z: 0 }, true);
    }

    const pos = rigidBody.translation();
    const rot = rigidBody.rotation();

    position = [pos.x, pos.y, pos.z];

    const isOnGround = pos.y <= -0.5;

    if (keys.w.pressed && isOnGround) {
      let currentSpeed = speed;

      if (keys.shift.pressed) {
        currentSpeed += 10;
      }

      const x = Math.sin(theta) * currentSpeed;
      const z = Math.cos(theta) * currentSpeed;
      const y = pos.y * currentSpeed;

      rigidBody.setLinvel({ x, y, z }, true);
    }
    controls.update(0, 0);

    const currentPosition = {
      x: pos.x,
      y: pos.y,
      z: pos.z,
    };

    const currentRotation = {
      x: rot.x,
      y: rot.y,
      z: rot.z,
      w: rot.w,
    };

    const result = {
      type: "playerMovement",
      position: currentPosition,
      rotation: currentRotation,
    };

    socket.send({
      type: "playerMovement",
      position: currentPosition,
      rotation: currentRotation,
    });
  });
</script>

<T.PerspectiveCamera makeDefault bind:ref={cameraRef}></T.PerspectiveCamera>

<Bullet {socket} {canonRef} />
<T.Group {position} bind:ref={mainGroupRef} dispose={false} {...props}>
  {#await gltf}
    {@render fallback?.()}
  {:then gltf}
    <RigidBody bind:rigidBody>
      <T.Group bind:ref={objectRef}>
        <!--  ID -->

        <HTML transform position={[0, 6, 0]} rotation.y={Math.PI / 1}>
          <span class="text-white text-xs">{player.id}</span>
        </HTML>

        <!-- flags -->
        <T.Mesh
          geometry={gltf.nodes.flag_obj.geometry}
          material={gltf.materials["Material.031"]}
        >
          <Outlines color="white" />
          <Outlines color="black" thickness={0.05} />
          <Outlines color="cyan" thickness={0.1} />
        </T.Mesh>

        <T.Mesh
          geometry={gltf.nodes.big_flag.geometry}
          material={gltf.materials["Material.034"]}
        >
          <Outlines color="white" />
          <Outlines color="black" thickness={0.05} />
          <Outlines color="cyan" thickness={0.1} />
        </T.Mesh>
        <T.Mesh
          geometry={gltf.nodes.flag.geometry}
          material={gltf.materials["Material.034"]}
        >
          <Outlines color="white" />
          <Outlines color="black" thickness={0.05} />
          <Outlines color="cyan" thickness={0.1} />
        </T.Mesh>

        <!-- Bardas -->

        <T.Mesh
          geometry={gltf.nodes.Cube.geometry}
          material={gltf.materials["Material.030"]}
        />
        <T.Mesh
          geometry={gltf.nodes.Cube001.geometry}
          material={gltf.materials["Material.031"]}
        />
        <T.Mesh
          geometry={gltf.nodes.Cube002.geometry}
          material={gltf.materials["Material.034"]}
        />

        <!-- boat -->

        <AutoColliders shape="cuboid">
          <T.Mesh
            geometry={gltf.nodes.Plane003.geometry}
            material={gltf.materials["Material.029"]}
          />
          <T.Mesh
            geometry={gltf.nodes.Plane003_1.geometry}
            material={gltf.materials["Material.030"]}
          >
            <Outlines color="white" />
            <Outlines color="black" thickness={0.05} />
            <Outlines color="cyan" thickness={0.1} />
          </T.Mesh>

          <T.Mesh
            geometry={gltf.nodes.Plane003_2.geometry}
            material={gltf.materials["border oro.001"]}
          />
        </AutoColliders>

        <!-- canon -->
        <AutoColliders shape="cuboid">
          <T.Mesh
            bind:ref={canonRef}
            geometry={gltf.nodes.Plane009.geometry}
            material={gltf.materials["Material.032"]}
          />
          <T.Mesh
            geometry={gltf.nodes.Plane009_1.geometry}
            material={gltf.materials["Material.033"]}
          />
        </AutoColliders>

        <T.Mesh
          geometry={gltf.nodes.Circle003.geometry}
          material={gltf.materials["Material.030"]}
        />
        <T.Mesh
          geometry={gltf.nodes.Circle003_1.geometry}
          material={gltf.materials["Material.031"]}
        />

        <T.Mesh
          geometry={gltf.nodes.Circle004.geometry}
          material={gltf.materials["Material.035"]}
        >
          <Outlines color="white" />
          <Outlines color="black" thickness={0.05} />
          <Outlines color="orange" thickness={0.1} />
        </T.Mesh>
        <T.Mesh
          geometry={gltf.nodes.Circle004_1.geometry}
          material={gltf.materials["Material.036"]}
        />
      </T.Group>
    </RigidBody>
  {:catch err}
    {@render error?.({ error: err })}
  {/await}

  {@render children?.({ ref })}
</T.Group>
