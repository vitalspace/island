<!--
    Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
    Command: npx @threlte/gltf@3.0.0 .\boat.glb -T --draco /draco/
    -->

<script lang="ts">
  import type { RigidBody as RapierRigidBody } from "@dimforge/rapier3d-compat";
  import { T, useTask } from "@threlte/core";
  import { useDraco, useGltf } from "@threlte/extras";
  import { AutoColliders, RigidBody } from "@threlte/rapier";
  import { Group, Quaternion, Vector3 } from "three";

  let {
    fallback = () => {},
    error = () => {},
    children = () => {},
    ref = $bindable(),
    ...props
  } = $props();

  const gltf = useGltf("/boat-transformed.glb", { dracoLoader: useDraco() });

  let position: [number, number, number] = $state<[number, number, number]>([
    -20, 0, 0,
  ]);

  let mainGroupRef: Group | undefined = $state<Group>();
  let objectRef: Group | undefined = $state<Group>();
  let rigidBody: RapierRigidBody | undefined = $state<RapierRigidBody>();

  const waypoints = $state([
    { x: -30, z: 0 },
    { x: -30, z: 30 },
    { x: 14, z: 35 },
    { x: 23, z: 50 },
    { x: 23, z: 50 },
    { x: 30, z: 60 },
    { x: 30, z: 0 },
    { x: 30, z: -20 },
    { x: 60, z: -20 },
    { x: 100, z: -30 },
    { x: 100, z: 50 },
    { x: 20, z: 0 },
    { x: 20, z: -30 },
    { x: -30, z: -30 },
  ]);

  let currentWaypointIndex = $state(0);
  let movementSpeed = 5; // Unidades por segundo
  let rotationSpeed = 2; // Velocidad de rotación
  let reachedThreshold = 0.5; // Distancia para considerar llegado a waypoint
  let targetDirection = $state(new Vector3());
  let currentVelocity = $state(new Vector3());

  // Función para calcular la rotación hacia la dirección
  const calculateRotation = (direction: Vector3) => {
    const angle = Math.atan2(direction.x, direction.z);
    return new Quaternion().setFromAxisAngle(new Vector3(0, 1, 0), angle);
  };

  useTask((delta) => {
    if (!rigidBody || !objectRef || !mainGroupRef) return;

    // Obtener posición actual
    const currentPosition = rigidBody.translation();

    // Calcular dirección al waypoint actual
    const target = waypoints[currentWaypointIndex];
    targetDirection
      .set(target.x - currentPosition.x, 0, target.z - currentPosition.z)
      .normalize();

    // Mover hacia el waypoint
    currentVelocity.copy(targetDirection.multiplyScalar(movementSpeed * delta));

    // Actualizar posición
    const newPosition = new Vector3(
      currentPosition.x + currentVelocity.x,
      currentPosition.y,
      currentPosition.z + currentVelocity.z
    );

    rigidBody.setTranslation(newPosition, true);

    // Calcular y aplicar rotación
    const targetQuaternion = calculateRotation(targetDirection);
    rigidBody.setRotation(targetQuaternion, true);

    // Verificar si se alcanzó el waypoint
    const distanceToTarget = Math.sqrt(
      Math.pow(target.x - newPosition.x, 2) +
        Math.pow(target.z - newPosition.z, 2)
    );

    if (distanceToTarget < reachedThreshold) {
      currentWaypointIndex = (currentWaypointIndex + 1) % waypoints.length;
    }

    // Actualizar posición para renderizado
    position = [newPosition.x, newPosition.y, newPosition.z];
  });
</script>

<T.Group
  {position}
  bind:ref={mainGroupRef}
  dispose={false}
  {...props}
  scale={1.5}
>
  {#await gltf}
    {@render fallback?.()}
  {:then gltf}
    <RigidBody bind:rigidBody>
      <T.Group bind:ref={objectRef}>
        <T.Mesh
          geometry={gltf.nodes.flag_obj.geometry}
          material={gltf.materials["Material.031"]}
        />
        <T.Mesh
          geometry={gltf.nodes.big_flag.geometry}
          material={gltf.materials["Material.034"]}
        />
        <T.Mesh
          geometry={gltf.nodes.flag.geometry}
          material={gltf.materials["Material.034"]}
        />
        <T.Mesh
          geometry={gltf.nodes.Cube.geometry}
          material={gltf.materials["Material.030"]}
        />
        <T.Mesh
          geometry={gltf.nodes.Cube001.geometry}
          material={gltf.materials["Material.031"]}
        />
        <T.Mesh
          geometry={gltf.nodes.Cube002.geometry}
          material={gltf.materials["Material.034"]}
        />
        <AutoColliders shape="cuboid">
          <T.Mesh
            geometry={gltf.nodes.Plane003.geometry}
            material={gltf.materials["Material.029"]}
          />
          <T.Mesh
            geometry={gltf.nodes.Plane003_1.geometry}
            material={gltf.materials["Material.030"]}
          />
          <T.Mesh
            geometry={gltf.nodes.Plane003_2.geometry}
            material={gltf.materials["border oro.001"]}
          />
        </AutoColliders>
        <AutoColliders shape="cuboid">
          <T.Mesh
            geometry={gltf.nodes.Plane009.geometry}
            material={gltf.materials["Material.032"]}
          />
          <T.Mesh
            geometry={gltf.nodes.Plane009_1.geometry}
            material={gltf.materials["Material.033"]}
          />
        </AutoColliders>

        <T.Mesh
          geometry={gltf.nodes.Circle003.geometry}
          material={gltf.materials["Material.030"]}
        />
        <T.Mesh
          geometry={gltf.nodes.Circle003_1.geometry}
          material={gltf.materials["Material.031"]}
        />
        <T.Mesh
          geometry={gltf.nodes.Circle004.geometry}
          material={gltf.materials["Material.035"]}
        />
        <T.Mesh
          geometry={gltf.nodes.Circle004_1.geometry}
          material={gltf.materials["Material.036"]}
        />
      </T.Group>
    </RigidBody>
  {:catch err}
    {@render error?.({ error: err })}
  {/await}

  {@render children?.({ ref })}
</T.Group>
